
from music21 import instrument, note, chord, stream, converter
import numpy as np

class MIDIConverter:

    def __init__(self):

        self.lowerBoundNote = 21
        self.resolution = 0.25

    def column2notes(self, column):
        notes = []
        for i in range(len(column)):
            if column[i] > 255/2:
                notes.append(i+self.lowerBoundNote)
        return notes

    def updateNotes(self, newNotes, prevNotes):
        res = {}
        for note in newNotes:
            if note in prevNotes:
                res[note] = prevNotes[note] + self.resolution
            else:
                res[note] = self.resolution
        return res

    def image2midi(self, image_path):
        with Image.open(image_path) as image:
            im_arr = np.frombuffer(image.tobytes(), dtype=np.uint8)
            try:
                im_arr = im_arr.reshape((image.size[1], image.size[0]))
            except:
                im_arr = im_arr.reshape((image.size[1], image.size[0], 3))
                im_arr = np.dot(im_arr, [0.33, 0.33, 0.33])

        """ convert the output from the prediction to notes and create a midi file
          from the notes """
        offset = 0
        output_notes = []

        # create note and chord objects based on the values generated by the model

        prev_notes = self.updateNotes(im_arr.T[0, :], {})
        for column in im_arr.T[1:, :]:
            notes = self.column2notes(column)
            # pattern is a chord
            notes_in_chord = notes
            old_notes = prev_notes.keys()
            for old_note in old_notes:
                if not old_note in notes_in_chord:
                    new_note = note.Note(
                        old_note, quarterLength=prev_notes[old_note])
                    new_note.storedInstrument = instrument.Piano()
                    if offset - prev_notes[old_note] >= 0:
                        new_note.offset = offset - prev_notes[old_note]
                        output_notes.append(new_note)
                    elif offset == 0:
                        new_note.offset = offset
                        output_notes.append(new_note)
                    else:
                        print(offset, prev_notes[old_note], old_note)

            prev_notes = self.updateNotes(notes_in_chord, prev_notes)

            # increase offset each iteration so that notes do not stack
            offset += self.resolution

        for old_note in prev_notes.keys():
            new_note = note.Note(old_note, quarterLength=prev_notes[old_note])
            new_note.storedInstrument = instrument.Piano()
            new_note.offset = offset - prev_notes[old_note]

            output_notes.append(new_note)

        prev_notes = self.updateNotes(notes_in_chord, prev_notes)
        
#         midi_stream = stream.Stream(output_notes)

#         midi_stream.write('midi', fp=image_path.split("/")
#                           [-1].replace(".png", ".mid"))
        return output_notes

    def extractNote(self, element):
        return int(element.pitch.ps)

    def extractDuration(self, element):
        return element.duration.quarterLength

    def get_notes(self, notes_to_parse):
        """ Get all the notes and chords from the midi files in the ./midi_songs directory """
        durations = []
        notes = []
        start = []

        for element in notes_to_parse:
            if isinstance(element, note.Note):
                if element.isRest:
                    continue

                start.append(element.offset)
                notes.append(self.extractNote(element))
                durations.append(self.extractDuration(element))

            elif isinstance(element, chord.Chord):
                if element.isRest:
                    continue
                for chord_note in element:
                    start.append(element.offset)
                    durations.append(self.extractDuration(element))
                    notes.append(self.extractNote(chord_note))

        return {"start": start, "pitch": notes, "dur": durations}

    def midi2image(self, midi_path, max_repetitions=float("inf"), resolution=0.25, lowerBoundNote=21, upperBoundNote=127, maxSongLength=100):
        mid = converter.parse(midi_path)

        instruments = instrument.partitionByInstrument(mid)

        data = {}

        try:
            i = 0
            for instrument_i in instruments.parts:
                notes_to_parse = instrument_i.recurse()

                notes_data = self.get_notes(notes_to_parse)
                if len(notes_data["start"]) == 0:
                    continue

                if instrument_i.partName is None:
                    data["instrument_{}".format(i)] = notes_data
                    i += 1
                else:
                    data[instrument_i.partName] = notes_data

        except:
            notes_to_parse = mid.flat.notes
            data["instrument_0"] = self.get_notes(notes_to_parse)

        for instrument_name, values in data.items():
            # https://en.wikipedia.org/wiki/Scientific_pitch_notation#Similar_systems

            pitches = values["pitch"]
            durs = values["dur"]
            starts = values["start"]

            index = 0
            while index < max_repetitions:
                matrix = np.zeros(
                    (upperBoundNote-lowerBoundNote, maxSongLength))

                for dur, start, pitch in zip(durs, starts, pitches):
                    dur = int(dur/resolution)
                    start = int(start/resolution)

                    if not start > index*(maxSongLength+1) or not dur+start < index*maxSongLength:
                        for j in range(start, start+dur):
                            if j - index*maxSongLength >= 0 and j - index*maxSongLength < maxSongLength:
                                matrix[pitch-lowerBoundNote, j -
                                       index*maxSongLength] = 255

                if matrix.any():  # If matrix contains no notes (only zeros) don't save it
                    # new_path = midi_path.split("/")[-1].replace(".mid",f"_{instrument_name}_{index}.png"
                    file_name = midi_path.split(
                        "/")[-1].replace(".mid", f"_{instrument_name}_{index}.png")
                    new_path = "generated_images/" + file_name
                    imwrite(new_path, matrix.astype(np.uint8))
                    index += 1
                else:
                    break
